<!--
 * @Author: OCEAN.GZY
 * @Date: 2023-12-28 11:30:42
 * @LastEditors: OCEAN.GZY
 * @LastEditTime: 2023-12-28 11:45:38
 * @FilePath: /c++/knowledge/c++线程池/static/desc/readme.md
 * @Description: 注释信息
-->
# c++11 手写线程池



## 并发和并行
- 并发：同一时间段内多个任务同时执行
  - 【单核上，多个线程占用CPU不同的时间片，物理上还是串行，但由于每个线程占用时间片短，看起来像多个线程在同时执行-->称作并发 concurrent】
- 并行：同一时刻多个任务同时执行
  - 【多核上，多个线程可以同时分配到不同的CPU上执行-->称作并行 parallel】

## 多线程的优势
### IO密集【程序指令涉及一些IO操作，比如设备、文件、网络操作(等待客户端连接IO操作是会阻塞住的)】
- CPU单核、CPU多核、多CPU，都比较符合多线程
  - 就绪队列  runable queue
  - 阻塞队列  blocking queue
### CPU密集型【程序指令都是做计算的】
- CPU单核
  - 多线程存在上下文切换，是额外的开销；【此时线程越多，上下文切换所话费的额外时间也越多，不如一个线程一直计算】
- CPU多核
  - 多个线程可以并行执行，对CPU利用率好

## 线程池
- 线程池是一种多线程处理形式，处理过程中将任务放入队列，然后在创建线程后开始工作
- 线程池的作用是限制系统中执行线程的数量，将最消耗资源的线程放入线程池中，让系统可以同时处理更多的任务
- 线程池的实现原理：任务 -> 队列 -> 线程 -> 执行


### 线程的消耗
- 【创建线程、线程切换、线程销毁】需要消耗系统资源，包括内存资源、CPU时间资源
- 线程栈本身占用大量内存
- 大量线程同时唤醒，会使系统经常出现锯齿状负载，或者瞬时负载量过大导致宕机

### 线程池的优势
- 在服务进程启动之初，就事先创建好线程池里面的线程
- 当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行task任务即可，
- task执行完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的task提供服务

#### fixed模式线程池
- 线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指
定

#### cached模式线程池
- 线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量
- 但是会设置一个线程数量的阈值
- 任务处理完成，如果动态增长的线程空闲了60s还没有处理其它任务，那么关闭线程，保持池中最初数量的线程即可
- 线程池的线程个数是动态变化的，所以被称为cached
  
## 线程同步
- 线程同步是多线程编程中需要特别注意的问题，多线程并发访问一个资源时，如果没有进行同步处理，可能会导致数据的不一致性
- 线程同步的目的是为了保证多线程并发访问时资源的正确性和一致性

### 线程互斥
- 互斥锁 mutex
- atomic 原子类型
### 线程通信
- 条件变量 condition_variable
- 信号量 semaphore