/**
* # 池：服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其运行效率。这就是池(pool)的概念
*       池是一组资源的集合，该组资源在服务器启动之初就完全创建好并初始化，称为静态资源分配
*       根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接
*   ##内存池
*       - 通常用于socket的接收缓存和发送缓存。
*       - 对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够(比如500字节)的接收缓存区是很合理的。
*       - 当客户请求的长度超过接收缓冲区的大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区
*   ##进程池和线程池
*       - 是并发编程常用的“伎俩”。
*       - 当我们需要一个工作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程池或线程池中取得一个执行实体，而无须动态地调用fork或pthread_create等函数来创建进程和线程
*   ## 连接池
*       - 通常用于服务器或服务器机群的内部永久连接。
*       - 每个逻辑单元可能都需要频繁地访问本地的某个数据库。简单的做法是:逻辑单元每次需要访问数据库的时候
*  # 数据复制
*   ## 高性能服务器应该避免不必要的数据复制
*        1. 尤其是当数据复制发生在用户代码和内核之间的时候。如果内核可以直接处理从socket 或者文件读入的数据，则应用程序就没必要将这 些数据从内核缓冲区复制到应用程序缓冲区中
*           - “直接处理” 指的是应用程序不关 心这些数据的内容，不需要对它们做任何分析。比如ftp 服务器，当客户请求一个文件时， 服务器只需要检测目标文件是否存在，以及客户是否有读取它的权限，而绝对不会关心文件 的具体内容。这样的话，ftp 服务器就无须把目标文件的内容完整地读人到应用程序缓冲区中 并调用send函数来发送，而是可以使用“零拷贝” 函数sendfle来直接将其发送给客户端
*        2. 用户代码内部(不访问内核)的数据复制也是应该避免的
*            - 当两个工作进程之间要传递大量的数据时，我们就应该考虑使用共享内存来在它们之间直接共享这些数据， 而不是使用管道或者消息队列来传递
*  # 上下文切换和锁
*   ## 并发程序必须考虑上下文(context switch)写换的问题,即进程切换或线程切换导致的系统开销
        - 即使是I/O密集型的服务器，也不应该使用过多的工作线程（或工作进程），否则线程间的切换将占用大量的CPU时间
        - 因此为每个客户连接都创建一个工作线程是不可取的
        - 多线程服务器的一个优点是不同线程可以同时运行在不同的CPU上； 当线程数量不大于CPU数目时，上下文的切换就不是问题了
    ## 并发程序需要考虑的另外 一个问题是共享资源的加锁保护。
        - 锁通常被认为是导致服务器效率低下的 一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源
        - 因此服务器如果有更好的解决方案，就应该避免使用锁
            - 如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写锁
                - 当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加系统的额外开销；只有某个线程需要写这块内存，系统才必须锁住这个区域
*/