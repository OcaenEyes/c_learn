<!--
 * @Author: OCEAN.GZY
 * @Date: 2023-12-28 11:30:42
 * @LastEditors: OCEAN.GZY
 * @LastEditTime: 2023-12-28 11:45:38
 * @FilePath: /c++/knowledge/c++线程池/static/desc/readme.md
 * @Description: 注释信息
-->
# c++11 手写线程池

> - 单线程模型【串行】
> - 多线程模型【并行】
> - 多进程模型【并行】
> - 分布式模型【并行】
> - 异步模型【并发】
> - 协程模型【并发】
> - 事件驱动模型【并发】
> - 消息队列模型【并发】
> - 信号量模型【并发】
> - 管道模型【并发】
> - 共享内存模型【并发】
> - 环形队列模型【并发】
> - 生产者消费者模型【并发】
>   - 生产者 thread1                            消费者 thread2
>   - 场景一：生产一个，消费一个                 场景二：先生产多个，之后再消费
>   ``` 
>      //生产者
>      std::unique_lock<std::mutex> lock(_mtx);
>      while(full){    
>         _cv.wait(lock); // 1.当生产者的容器存满之后，会改变线程的状态(进入等待状态)，并放锁
>      }
>      生产一个新的
>      _cv.notify_all(); // 广播有新的了，通知消费者消费   
>      
>     出了生产者函数的作用域之后， lock==> _mtx // 2.生产者函数执行完毕，释放锁
>
>
>     =======================分割线======================
>
>
>     // 消费者
>      std::unique_lock<std::mutex> lock(_mtx);
>      while(empty){    
>         _cv.wait(lock); // 1.当消费者抢到锁，但是发现容器是空的，会改变线程的状态(进入等待状态)，并放锁     [等待->阻塞->拿到锁->执行->释放锁]
>      }
>
>      消费掉一个
>      _cv.notify_all(); // 广播被消费掉了，通知生产者继续生产
> 
>      出了消费者函数的作用域之后， lock==> _mtx // 2.消费者函数执行完毕，释放锁
>
>
>   ```
> - 线程池模型【并发】
> - 协程池模型【并发】
> - 事件循环模型【并发】



## 并发和并行
- 并发：同一时间段内多个任务同时执行
  - 【单核上，多个线程占用CPU不同的时间片，物理上还是串行，但由于每个线程占用时间片短，看起来像多个线程在同时执行-->称作并发 concurrent】
- 并行：同一时刻多个任务同时执行
  - 【多核上，多个线程可以同时分配到不同的CPU上执行-->称作并行 parallel】

## 多线程的优势
### IO密集【程序指令涉及一些IO操作，比如设备、文件、网络操作(等待客户端连接IO操作是会阻塞住的)】
- CPU单核、CPU多核、多CPU，都比较符合多线程
  - 就绪队列  runable queue
  - 阻塞队列  blocking queue
### CPU密集型【程序指令都是做计算的】
- CPU单核
  - 多线程存在上下文切换，是额外的开销；【此时线程越多，上下文切换所话费的额外时间也越多，不如一个线程一直计算】
- CPU多核
  - 多个线程可以并行执行，对CPU利用率好

## 线程池
- 线程池是一种多线程处理形式，处理过程中将任务放入队列，然后在创建线程后开始工作
- 线程池的作用是限制系统中执行线程的数量，将最消耗资源的线程放入线程池中，让系统可以同时处理更多的任务
- 线程池的实现原理：任务 -> 队列 -> 线程 -> 执行


### 线程的消耗
- 【创建线程、线程切换、线程销毁】需要消耗系统资源，包括内存资源、CPU时间资源
- 线程栈本身占用大量内存【线程函数占用的内存】
- 大量线程同时唤醒，会使系统经常出现锯齿状负载，或者瞬时负载量过大导致宕机

### 线程池的优势
- 在服务进程启动之初，就事先创建好线程池里面的线程
- 当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行task任务即可，
- task执行完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的task提供服务

#### fixed模式线程池
- 线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定

#### cached模式线程池
- 线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量
- 但是会设置一个线程数量的阈值
- 任务处理完成，如果动态增长的线程空闲了60s还没有处理其它任务，那么关闭线程，保持池中最初数量的线程即可
- 线程池的线程个数是动态变化的，所以被称为cached
  
## 线程同步【】
- 线程同步是多线程编程中需要特别注意的问题，多线程并发访问一个资源时，如果没有进行同步处理，可能会导致数据的不一致性
- 线程同步的目的是为了保证多线程并发访问时资源的正确性和一致性


### 线程互斥【同一时刻，只允许一个线程访问共享资源】
> - 什么是线程互斥？ ===> 同一时刻，只允许一个线程访问共享资源
> - 能不能在多线程环境下运行？ ===> 看这段代码是否存在 竞态条件 【代码片段在多线程环境下，随着线程的调度顺序不同，而得到不同的结果】
>   - 存在竞态条件race condition的代码段【临界区critical section代码段】 ====>保证它的原子操作
> - 如果在多线程环境下是不存在竞态条件的 ====>可重入
> - 如果在多线程环境下是存在竞态条件的 ====>不可重入， 需要保证原子操作， 需要用线程互斥

- 互斥锁 mutex
  - c++11 lock_guard 、unique_lock
  - mutex互斥锁 ===> 资源计数只能是0  或 1
  - mutex.lock() ===> 加锁，锁的资源计数 从1 变为0
  - mutex.try_lock() ===> 尝试加锁
  - mutex.unlock() ===> 解锁， 锁的资源计数 从0 变为1
- atomic 原子类型
  - c++11 CAS操作(无锁机制)



### 线程通信【线程之间传递消息】
> - 一个线程依赖另一个线程的执行结果
> - 线程A执行完毕后，需要通知线程B，线程B才能继续执行
> - 线程A和线程B之间需要通信传递消息

- 条件变量 condition_variable
  - Linux pthead
    - pthread_cond_wait
    - pthread_cond_signal
    - pthread_cond_broadcast
  - windows
    - wait_for_single_object
    - set_event
    - reset_event
    - pulse_event
  - c++11 condition_variable 需要和 mutex一起使用
    - wait 进入等待状态
    - notify_one 通知一个
    - notify_all 通知所有

- 信号量 semaphore 【看作资源计数没有限制的mutex互斥锁】

  - c++20 std::semaphore
  ```
  std::semaphore sem(0); // 初始化信号量，初始值为0

  // 生产者线程A

  生产一个新的;
  sem.post(); // 增加信号量，增加一个资源




  // 消费者线程B

  sem.wait(); // 等待信号量
  消费掉一个


  ```